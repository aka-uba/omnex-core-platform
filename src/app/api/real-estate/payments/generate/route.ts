import { NextRequest } from 'next/server';
import { withTenant } from '@/lib/api/withTenant';
import { successResponse, errorResponse } from '@/lib/api/errorHandler';
import type { ApiResponse } from '@/lib/api/errorHandler';
import { getTenantFromRequest } from '@/lib/api/tenantContext';
import { Prisma } from '@prisma/tenant-client';
import dayjs from 'dayjs';

/**
 * POST /api/real-estate/payments/generate
 * Generate payments automatically from active contracts
 * 
 * This endpoint generates monthly rent payments for active contracts
 * based on their paymentDay setting and rentAmount.
 */
export async function POST(request: NextRequest) {
  return withTenant<ApiResponse<{ generated: number; skipped: number; errors: unknown[] }>>(
    request,
    async (tenantPrisma) => {
      // Get tenant context
      const tenantContext = await getTenantFromRequest(request);
      if (!tenantContext) {
        return errorResponse('Tenant context required', 'Tenant context could not be determined', 400);
      }

      const body = await request.json();
      const { month, year, contractIds } = body; // Optional: specific contracts or all active

      // Use provided month/year or current month
      const targetMonth = month || dayjs().month() + 1; // 1-12
      const targetYear = year || dayjs().year();
      const targetDate = dayjs().year(targetYear).month(targetMonth - 1);

      // Get companyId
      const firstCompany = await tenantPrisma.company.findFirst({
        select: { id: true },
        orderBy: { createdAt: 'asc' },
      });

      if (!firstCompany) {
        return errorResponse('Validation error', 'No company found for tenant', 404);
      }

      const companyId = firstCompany.id;

      // Find active contracts
      // Build where clause with tenant and company isolation (defense-in-depth)
      const whereClause: Prisma.ContractWhereInput = {
        tenantId: tenantContext.id,
        status: 'active',
      };

      if (contractIds && Array.isArray(contractIds) && contractIds.length > 0) {
        whereClause.id = { in: contractIds };
      }

      const activeContracts = await tenantPrisma.contract.findMany({
        where: whereClause,
        include: {
          apartment: {
            select: {
              id: true,
              unitNumber: true,
            },
          },
          tenantRecord: {
            select: {
              id: true,
            },
          },
        },
      });

      let generated = 0;
      let skipped = 0;
      const errors: Array<{ contractId: string; error: string }> = [];

      for (const contract of activeContracts) {
        try {
          // Skip if contract doesn't have paymentDay set
          if (!contract.paymentDay) {
            skipped++;
            continue;
          }

          // Calculate due date for this month
          const daysInMonth = targetDate.daysInMonth();
          const paymentDay = Math.min(contract.paymentDay, daysInMonth);
          const dueDate = targetDate.date(paymentDay).startOf('day').toDate();

          // Check if payment already exists for this contract and month
          const existingPayment = await tenantPrisma.payment.findFirst({
            where: {
              tenantId: tenantContext.id,
              contractId: contract.id,
              type: 'rent',
              dueDate: {
                gte: targetDate.startOf('month').toDate(),
                lte: targetDate.endOf('month').toDate(),
              },
            },
          });

          if (existingPayment) {
            skipped++;
            continue;
          }

          // Create payment
          await tenantPrisma.payment.create({
            data: {
              tenantId: tenantContext.id,
              companyId: companyId,
              apartmentId: contract.apartmentId,
              contractId: contract.id,
              type: 'rent',
              amount: contract.rentAmount,
              currency: contract.currency || 'TRY',
              dueDate: dueDate,
              status: 'pending',
              totalAmount: contract.rentAmount,
              isAutoGenerated: true,
              reminderSent: false,
            },
          });

          generated++;
        } catch (error: any) {
          errors.push({
            contractId: contract.id,
            error: error.message || 'Unknown error',
          });
        }
      }

      return successResponse({
        generated,
        skipped,
        errors,
      });
    },
    { required: true, module: 'real-estate' }
  );
}








