#!/usr/bin/env node

/**
 * Schema Merge Script
 * 
 * Birle≈ütirir:
 * 1. Core base modelleri (user, company, permissions, menu)
 * 2. Extensions (audit, notifications, files, ai, meta, schema-registry)
 * 3. Modules (real-estate, accounting, production, hr, chat, maintenance, web-builder)
 * 
 * Validasyonlar:
 * - Duplicate model name detection
 * - Broken relation target detection
 * - Relation policy validation (whitelist kontrol√º)
 */

const fs = require('fs');
const path = require('path');
const { isDevMode, handleValidation } = require('./operational-mode');

const PRISMA_DIR = path.join(__dirname, '../prisma');
const OUTPUT_SCHEMA = path.join(PRISMA_DIR, 'tenant.schema.prisma');

// Core base (her zaman ilk)
const CORE_BASE_HEADER = `
// ============================================
// CORE BASE (Required for all tenants)
// ============================================
`;

// Extensions header
const EXTENSIONS_HEADER = `
// ============================================
// EXTENSIONS (Cross-cutting concerns)
// ============================================
`;

// Modules header
const MODULES_HEADER = `
// ============================================
// MODULES (Module-specific schemas)
// ============================================
`;

// Schema header
const SCHEMA_HEADER = `// Tenant Database Schema
// Auto-generated from modular schemas - DO NOT EDIT MANUALLY
// Generated at: ${new Date().toISOString()}
// 
// This file is automatically generated by scripts/merge-schemas.js
// Manual edits will be overwritten on next merge.

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/tenant-client"
}

datasource db {
  provider = "postgresql"
  url      = env("TENANT_DATABASE_URL")
}

`;

// Model name tracking
const modelNames = new Set();
const modelDefinitions = new Map();
const relations = [];

/**
 * Parse Prisma schema file and extract models
 */
function parseSchemaFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return { models: [], relations: [] };
  }

  const content = fs.readFileSync(filePath, 'utf8');
  const models = [];
  const fileRelations = [];
  
  // Extract model definitions
  const modelRegex = /model\s+(\w+)\s*\{([^}]+(?:\{[^}]*\}[^}]*)*)\}/gs;
  let match;
  
  while ((match = modelRegex.exec(content)) !== null) {
    const modelName = match[1];
    const modelBody = match[2];
    
    models.push({
      name: modelName,
      body: modelBody,
      file: path.basename(filePath)
    });
    
    // Extract relations
    // Pattern: fieldName ModelName?[]? @relation(...)
    // Example: user User @relation(fields: [userId], references: [id])
    //          parent Location? @relation("LocationHierarchy", fields: [parentId], references: [id])
    const relationRegex = /(\w+)\s+(\w+)\??(\[?\])?\s+@relation\([^)]*fields:\s*\[([^\]]+)\][^)]*references:\s*\[([^\]]+)\][^)]*\)/gs;
    let relationMatch;
    while ((relationMatch = relationRegex.exec(modelBody)) !== null) {
      const fieldName = relationMatch[1].trim(); // e.g., "user"
      const toModel = relationMatch[2].trim(); // e.g., "User" - THIS IS THE MODEL NAME
      const foreignKey = relationMatch[4].trim(); // e.g., "userId"
      const referencedField = relationMatch[5].trim(); // e.g., "id"
      
      // The model name is in the type, not in references
      fileRelations.push({
        from: modelName,
        to: toModel,
        field: fieldName,
        foreignKey: foreignKey,
        referencedField: referencedField
      });
    }
  }
  
  return { models, relations: fileRelations };
}

/**
 * Check for duplicate model names
 */
function checkDuplicateModels(models) {
  const duplicates = [];
  const seen = new Set();
  
  for (const model of models) {
    if (seen.has(model.name)) {
      duplicates.push(model.name);
    }
    seen.add(model.name);
  }
  
  if (duplicates.length > 0) {
    const message = `Duplicate model names found: ${duplicates.join(', ')}`;
    handleValidation(new Error(message), message);
  }
  
  return duplicates.length === 0;
}

/**
 * Check for broken relation targets
 */
function checkBrokenRelations(models, relations) {
  const modelNameSet = new Set(models.map(m => m.name));
  const broken = [];
  
  for (const rel of relations) {
    if (!modelNameSet.has(rel.to)) {
      broken.push(`${rel.from} -> ${rel.to} (field: ${rel.field})`);
    }
  }
  
  if (broken.length > 0) {
    const message = `Broken relation targets found:\n${broken.map(b => `  - ${b}`).join('\n')}`;
    handleValidation(new Error(message), message);
  }
  
  return broken.length === 0;
}

/**
 * Merge schemas
 */
function mergeSchemas() {
  let merged = SCHEMA_HEADER;
  const allModels = [];
  const allRelations = [];
  
  // 1. Core base models
  merged += CORE_BASE_HEADER;
  const coreBaseFiles = [
    'user.prisma',
    'company.prisma',
    'permissions.prisma',
    'menu.prisma'
  ];
  
  for (const file of coreBaseFiles) {
    const filePath = path.join(PRISMA_DIR, 'core-base', file);
    if (fs.existsSync(filePath)) {
      const { models, relations } = parseSchemaFile(filePath);
      allModels.push(...models);
      allRelations.push(...relations);
      
      merged += `\n// From: core-base/${file}\n`;
      merged += fs.readFileSync(filePath, 'utf8');
      merged += '\n\n';
    }
  }
  
  // 2. Extensions
  merged += EXTENSIONS_HEADER;
  const extensionFiles = fs.readdirSync(path.join(PRISMA_DIR, 'extensions'))
    .filter(f => f.endsWith('.prisma'))
    .sort();
  
  for (const file of extensionFiles) {
    const filePath = path.join(PRISMA_DIR, 'extensions', file);
    const { models, relations } = parseSchemaFile(filePath);
    allModels.push(...models);
    allRelations.push(...relations);
    
    merged += `\n// From: extensions/${file}\n`;
    merged += fs.readFileSync(filePath, 'utf8');
    merged += '\n\n';
  }
  
  // 3. Modules
  merged += MODULES_HEADER;
  const moduleDirs = fs.readdirSync(path.join(PRISMA_DIR, 'modules'))
    .filter(f => {
      const fullPath = path.join(PRISMA_DIR, 'modules', f);
      return fs.statSync(fullPath).isDirectory();
    })
    .sort();
  
  for (const moduleDir of moduleDirs) {
    const moduleSchema = path.join(PRISMA_DIR, 'modules', moduleDir, `${moduleDir}.prisma`);
    if (fs.existsSync(moduleSchema)) {
      const { models, relations } = parseSchemaFile(moduleSchema);
      allModels.push(...models);
      allRelations.push(...relations);
      
      merged += `\n// From: modules/${moduleDir}/${moduleDir}.prisma\n`;
      merged += fs.readFileSync(moduleSchema, 'utf8');
      merged += '\n\n';
    }
  }
  
  // Validations
  console.log('üîç Validating merged schema...');
  
  // Check duplicates
  if (!checkDuplicateModels(allModels)) {
    if (isDevMode()) {
      console.warn('‚ö†Ô∏è  Continuing despite duplicate models (DEV MODE)');
    } else {
      console.error('‚ùå Duplicate models found. Aborting.');
      process.exit(1);
    }
  }
  
  // Check broken relations
  if (!checkBrokenRelations(allModels, allRelations)) {
    if (isDevMode()) {
      console.warn('‚ö†Ô∏è  Continuing despite broken relations (DEV MODE)');
    } else {
      console.error('‚ùå Broken relations found. Aborting.');
      process.exit(1);
    }
  }
  
  // Write merged schema
  fs.writeFileSync(OUTPUT_SCHEMA, merged);
  console.log(`‚úÖ Schema merged successfully: ${OUTPUT_SCHEMA}`);
  console.log(`   Total models: ${allModels.length}`);
  console.log(`   Total relations: ${allRelations.length}`);
  console.log(`   Mode: ${isDevMode() ? 'DEV' : 'GUARDED'}`);
}

// Run merge
try {
  mergeSchemas();
} catch (error) {
  console.error('‚ùå Error merging schemas:', error.message);
  process.exit(1);
}

